# -*- coding: utf-8 -*-
"""Internal Exam 2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jK8fnu3Fr_qVBa2p6PBm-Krw3x1Us5NM
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv('/content/train_ctrUa4K.csv')

df.head()

df.isna().sum()

df.info()

df.shape

df.describe()

import matplotlib.pyplot as plt
df.hist(figsize=(12,10))
plt.show()

df.columns

#handle missing values
df.isnull().sum()

df['Gender'].fillna(df['Gender'].mode()[0],inplace=True)

df['Married'].fillna(df['Married'].mode()[0],inplace=True)

df['Dependents'].fillna(df['Dependents'].mode()[0],inplace=True)

df['Self_Employed'].fillna(df['Self_Employed'].mode()[0],inplace=True)

df['LoanAmount'].fillna(df['LoanAmount'].mean(),inplace=True)

df['Loan_Amount_Term'].fillna(df['Loan_Amount_Term'].mean(),inplace=True)

df['Credit_History'].fillna(df['Credit_History'].mean(),inplace=True)

df.isna().sum()

df.head()

#apply label encoding to the object columns
from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()

df['Gender'] = le.fit_transform(df['Gender'])
df['Married'] = le.fit_transform(df['Married'])
df['Education'] = le.fit_transform(df['Education'])
df['Property_Area'] = le.fit_transform(df['Property_Area'])
df['Loan_Status'] = le.fit_transform(df['Loan_Status'])
df['Self_Employed'] = le.fit_transform(df['Self_Employed'])

df.head()

df.info()

df['Loan_ID'] = df['Loan_ID'].str.extract('(\d+)').astype(int)

df.head()

#plot boxplot of all the columns
plt.figure(figsize=(12,10))
sns.boxplot(data=df)
plt.show()

def detect_outliers_iqr(df):
    outliers = {}
    for column in df.select_dtypes(include=['float64', 'int64']).columns:
        # Calculate Q1 (25th percentile) and Q3 (75th percentile)
        Q1 = df[column].quantile(0.25)
        Q3 = df[column].quantile(0.75)
        # Calculate IQR
        IQR = Q3 - Q1
        # Determine outlier bounds
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        # Count the number of outliers
        outlier_count = ((df[column] < lower_bound) | (df[column] > upper_bound)).sum()
        outliers[column] = outlier_count
    return outliers

# Detect outliers in the dataset
outlier_counts = detect_outliers_iqr(df)

# Display the number of outliers for each column
print("Number of Outliers in Each Column:")
for column, count in outlier_counts.items():
    print(f"{column}: {count}")

df.shape

df['Gender'].unique()

df['Married'].unique()

#scaling
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()

# Handle non-numerical values in 'Dependents' column
df['Dependents'] = df['Dependents'].replace('3+', 3)  # Replace '3+' with 3
df['Dependents'] = df['Dependents'].astype(float)  # Convert to float



# Now apply the scaler
df[['ApplicantIncome', 'CoapplicantIncome', 'LoanAmount', 'Loan_Amount_Term', 'Credit_History']] = scaler.fit_transform(
    df[['ApplicantIncome', 'CoapplicantIncome', 'LoanAmount', 'Loan_Amount_Term', 'Credit_History']]
)

df.head()

correlation_matrix = df.corr()

plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5)


plt.title('Correlation Matrix')
plt.show()

# prompt: my target column is loan_status so i need the columns having high correlation to loan_status

# Assuming 'Loan_Status' is the target column
target_correlations = correlation_matrix['Loan_Status'].abs().sort_values(ascending=False)

# Set a threshold for high correlation (e.g., 0.1)
high_correlation_threshold = 0.1

# Select columns with high correlation to the target
high_corr_columns = target_correlations[target_correlations > high_correlation_threshold]

print("Columns with high correlation to Loan_Status:")
print(high_corr_columns)

dff=pd.read_csv('/content/test_lAUu6dG.csv')

dff.head()

dff.isna().sum()

dff['Gender'].fillna(dff['Gender'].mode()[0],inplace=True)

dff['Dependents'].fillna(dff['Dependents'].mode()[0],inplace=True)

dff['Self_Employed'].fillna(dff['Self_Employed'].mode()[0],inplace=True)

dff['LoanAmount'].fillna(dff['LoanAmount'].mean(),inplace=True)

dff['Loan_Amount_Term'].fillna(dff['Loan_Amount_Term'].mean(),inplace=True)

dff['Credit_History'].fillna(dff['Credit_History'].mean(),inplace=True)

dff.isna().sum()

dff['Dependents'] = dff['Dependents'].replace('3+', 3)  # Replace '3+' with 3
dff['Dependents'] = dff['Dependents'].astype(float)  # Convert to float


#scaling
dff['Gender'] = le.fit_transform(dff['Gender'])
dff['Married'] = le.fit_transform(dff['Married'])
dff['Education'] = le.fit_transform(dff['Education'])
dff['Property_Area'] = le.fit_transform(dff['Property_Area'])
dff['Self_Employed'] = le.fit_transform(dff['Self_Employed'])

dff.head()

dff['Loan_ID'] = dff['Loan_ID'].str.extract('(\d+)').astype(int)

df.drop('Gender',axis=1,inplace=True)

df.drop('Married',axis=1,inplace=True)

dff.drop('Gender',axis=1,inplace=True)

dff.drop('Married',axis=1,inplace=True)

dff[['ApplicantIncome', 'CoapplicantIncome', 'LoanAmount', 'Loan_Amount_Term', 'Credit_History']] = scaler.fit_transform(
    dff[['ApplicantIncome', 'CoapplicantIncome', 'LoanAmount', 'Loan_Amount_Term', 'Credit_History']])

dff.head()

df.columns

"""classification"""

X_train = df[['Loan_ID', 'Dependents', 'Education', 'Self_Employed',
                    'ApplicantIncome', 'CoapplicantIncome', 'LoanAmount',
                    'Loan_Amount_Term', 'Credit_History', 'Property_Area']]
y_train = df['Loan_Status']

X_test = dff[['Loan_ID', 'Dependents', 'Education', 'Self_Employed',
                  'ApplicantIncome', 'CoapplicantIncome', 'LoanAmount',
                  'Loan_Amount_Term', 'Credit_History', 'Property_Area']]

from sklearn.linear_model import LogisticRegression
lr = LogisticRegression(max_iter=1000)

lr.fit(X_train, y_train)

predicted = lr.predict(X_test)

# prompt: i want to convert this array into dataframe as Y =1 and N =0 as predicted data is loan status

import pandas as pd
y_pred_df = pd.DataFrame(predicted, columns=['Loan_Status'])
y_pred_df['Loan_Status'] = y_pred_df['Loan_Status'].replace({1: 'Y', 0: 'N'})

predicted

y_pred_df

# prompt: i want to add loan id along with corrsponidng predicted loan status

import pandas as pd
# Assuming 'Loan_ID' is in X_test
result_df = pd.DataFrame({'Loan_ID': X_test['Loan_ID'], 'Loan_Status': y_pred_df['Loan_Status']})
print(result_df)

dff.head()

result_df.head()

# prompt: add LP00 infront of loan_id values at a time only in result_df

result_df['Loan_ID'] = 'LP00' + result_df['Loan_ID'].astype(str)
result_df

# prompt: convert into csv file

result_df.to_csv('/content/sample_submission_49d68Cx.csv', index=False)

